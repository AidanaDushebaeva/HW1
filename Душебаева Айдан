ЗАДАЧА
В приложенных файлах вы увидите данные по прохождению студентами тестов на образовательной платформе. Такие данные могут быть использованы для построения персонализированных ИИ-ассистентов для поддержки обучения студента. На текущем этапе сосредоточимся на начальном этапе — сборе и подготовке данных.

ВАМ НЕОБХОДИМО:

• Используя библиотеку pandas (или аналоги), проанализировать как можно больше характеристик, влияющих на успеваемость студентов.

Описание данных
Файл train.csv:
Этот файл содержит основной набор данных для обучения моделей и включает следующую информацию:

row_id: (int64) Уникальный идентификатор строки.
timestamp: (int64) Время в миллисекундах между текущим взаимодействием пользователя и его первым событием на платформе.
user_id: (int32) Уникальный идентификатор пользователя.
content_id: (int16) Идентификатор контента (вопрос или лекция).
content_type_id: (int8) Тип контента: 0 — вопрос, 1 — лекция.
task_container_id: (int16) Идентификатор группы вопросов или лекций, показанных подряд.
user_answer: (int8) Ответ пользователя на вопрос (если был дан). Значение -1 указывает на лекцию, где нет ответа.
answered_correctly: (int8) Флаг, указывающий на правильность ответа (1 — правильно, 0 — неправильно). Для лекций значение -1.
prior_question_elapsed_time: (float32) Среднее время в миллисекундах, затраченное на решение каждого вопроса из предыдущего блока вопросов. Для лекций значение пустое.
prior_question_had_explanation: (bool) Флаг, указывающий, видел ли пользователь объяснение правильного ответа после предыдущего блока вопросов. Пусто для первых взаимодействий пользователя.
Файл questions.csv:
Содержит метаданные для вопросов, заданных пользователям.

question_id: Внешний ключ, связывающий с колонкой content_id в файле train/test (когда content_type_id равно 0).
bundle_id: Идентификатор группы вопросов, показанных вместе.
correct_answer: Правильный ответ на вопрос. Можно сравнивать с колонкой user_answer для проверки правильности ответа.
part: Номер секции теста TOEIC, к которой относится вопрос.
tags: Один или несколько кодов, описывающих вопрос. Они могут использоваться для кластеризации вопросов.
Файл lectures.csv:
Содержит метаданные для лекций, просмотренных пользователями.

lecture_id: Внешний ключ для колонки content_id в файле train/test (когда content_type_id равно 1).
part: Категория лекции на высоком уровне.
tag: Один код для лекции, который можно использовать для кластеризации.
type_of: Краткое описание цели лекции.
0. Конфигурация
In [1]:
TRAIN = '/kaggle/input/test-results/test_results/train.csv'
QUESTIONS = '/kaggle/input/test-results/test_results/questions.csv'
LECTURES = '/kaggle/input/test-results/test_results/lectures.csv'
1. Импорт зависимостей
In [28]:
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings("ignore") 
2. Загрузка данных и проведение анализа
Функция load_sample_users_data предназначена для выборочной загрузки данных из большого файла, чтобы снизить нагрузку на оперативную память. Полная загрузка всех данных может потребовать слишком много ресурсов, поэтому функция загружает данные только для определённого количества уникальных пользователей.

In [29]:
def load_sample_users_data(file_path, num_users=1000):
    """
    Функция загружает данные для определённого количества уникальных пользователей из большого файла CSV.
    
    :param file_path: Путь к файлу CSV
    :param num_users: Количество уникальных пользователей, для которых нужно загрузить данные
    :return: DataFrame с данными для выбранных пользователей
    """
    # Сначала загружаем файл с определёнными столбцами для экономии памяти
    df = pd.read_csv(file_path, usecols=['user_id'])
    
    # Выбираем num_users уникальных пользователей
    unique_users = df['user_id'].drop_duplicates().sample(n=num_users, random_state=42)
    
    # Загружаем данные только для выбранных пользователей
    user_data = pd.read_csv(file_path)
    
    # Оставляем только данные для выбранных пользователей
    filtered_data = user_data[user_data['user_id'].isin(unique_users)]
    
    return filtered_data
In [30]:
# Загрузка выборки данных
train_df = load_sample_users_data(TRAIN, num_users=1000)
